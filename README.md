# Домашнее задание к занятию 3.2. Работа в терминале, лекция 2
## 1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.  
ввод:  
~$ type cd  
вывод:  
cd is a shell builtin - cd встроенная оболочка. Возможно это связано с работой в окружении влиянием на процесс который ее вызвал.  

## 2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос.   

grep с параметром -c, --count.  
Этот параметр выводит количество совпадающих строк для каждого входного файла.   

## 3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?  
Это systemd.  
Получено с помощью pstree -p  .  

## 4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?  
Эта команда будет выглядеть вот так: ls 2>/dev/pts/0   
где: ls это сама команда , 2>/dev/pts/0 это перенеправление вывода в терминал 0.При открытии еще одного терминала происходит создание PTS устройства по адресу /dev/pts/Х, где Х-номер устройства т.е. терминала.  
Потоки данных имеют номера 0, 1и 2.  
Если мы поставим 1 вместо 2 , то будет происходить перенеправление вывода не ошибок, а результатов выдачи работы  команды, в терминал 0.  
если мы поставим & перед > , то будет происходить перенеправление вывода и ошибок, и результатов выдачи работы  команды, в терминал 0.  

## 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.  
Получится, пусть есть файл, text_in.txt, мы его отдаем команде cat:  
cat <text_in.txt  
на экране будет выведено содержимое файла. И этот вывод можно перенаправить в файл, пусть  зовется text_out.txt и будет:  
cat <text_in.txt >>text_out.txt  
Для проверки смотрим файл:  
cat text_out.txt  
Если повторить cat <text_in.txt >>text_out.txt несколько раз то в выходной файл будет дописываться содержимое входного файла т.к. стоит >> .  

## 6.Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?  

Вот тут я не очень понял  
tty это терминал, который является программой эмуляций телетайпа (виртуальная консоль) по сути его графическая реализация;  
pts это наши виртуальные терминалы, т.е посути порты которые ввод получают не с клавиатуры, а с master устройства, а вывод идет не на дисплей, а на master устройство.    
ptm это ведущая часть виртуального терминала (master).    

Можно попробывать, что то такое echo Текст >/dev/ttyN , где N это номер даваемый командой tty.  


## 7. Выполните команду bash 5>&1. К чему она приведет? Почему так происходит?  
>& создает дескриптор 5 для файла и отправляет туда вывод 1   

Что будет, если вы выполните echo netology > /proc/$$/fd/5?   
как понял "файлы/ссылки" дискрипторов хранятся по адресу /proc/$$/fd/номер_дискриптора . И эта команда выведет слово "netology" в созданный дескриптор. Выполнение этой команды в новой сессии приведет к ошибке, т.к. нету дескриптора 5.  

## 8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.  
 
Берем команду и делаем перенаправление с помощью >& аа для проверки мы можем поискать какие-нибудь слова из ошибок.   
Например : ls -l  для директории /bash_history ,а ее дискрипторы перенаправляем 5>&2 2>&1 1>&5 , тут будет pipe | , а после поиск по слову которое есть в ошибке grep "directory"  
ls -l /bash_history 5>&2 2>&1 1>&5 |grep "directory"  
это выведет собщение о ошибке  переданное из левой части пайпа.  

## 9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?  

Содержит переменные среды процесса чей PID подставляется в место $$, если ввести так то будет PID той оболочки из которой подключился. Можно командой env или export.   

## 10. Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.   

/proc/<PID>/cmdline – команда, и её параметры, с помощью которой был запущен процесс. ( man proc строка 233)   
/proc/<PID>/exe -  этот файл представляет собой символическую ссылку, содержащую фактический путь к исполняемой команде. ( man proc строка 288)   

## 11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.  

grep sse /proc/cpuinfo  

Вывод:    
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid tsc_known_freq pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm cmp_legacy cr8_legacy abm sse4a misalignsse 3dnowprefetch ssbd vmmcall fsgsbase avx2 rdseed clflushopt arat  
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid tsc_known_freq pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm cmp_legacy cr8_legacy abm sse4a misalignsse 3dnowprefetch ssbd vmmcall fsgsbase avx2 rdseed clflushopt arat  

Судя по всему самая старая будет SSE 4.1   

## 12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:   
vagrant@netology1:~$ ssh localhost 'tty'   
not a tty   
Почитайте, почему так происходит, и как изменить поведение.   

у меня не получилось добиться такого же вывода как в задании. Но судя по выводу в задании нету созданого tty, из мануала известно стало,  что -t принудительно выделяет псевдотерминал.   

## 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.   
Из найденого мануала https://github.com/nelhage/reptyr#readme  
Запускаем процесс отправляем его в фоновый режим и отсоединяем от родителя(вроде так). В другом терминале мы запускаем screen и используем reptyre <PID процесса> и этот процесс перейдет в screen и будет отображаться ч\з pstree -p.   

## 14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.  

tee-считывает стандартный ввод (stdin), после чего записывает его в стандартный вывод (stdout) и одновременно копирует его в подготовленный файл или переменну, по сути работает как "тройник/разветвитель".
Например, я попробывал сделать так:  
ls -la | tee tee_out.txt  
В результате я получу вывод списка файлов и папок , а так же файл tee_out.txt, расположенный в текущей директории, в который будет записан вывод команды ls -la. Таким образом конструкция echo string | sudo tee /root/new_file имеет запуск tee от суперпользователя со всеми привелегиями.   

